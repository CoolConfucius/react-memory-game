mar25
issues getting messy. 
notes start here. 

react made decision react is agonna update in dom...
understandign life cycle hooks is what takes you from beginer to medium react dev

Event pooling
you have synthesized event object. can't use it asynchronisly. react reuses this event. 
null because react is doign event pooling. 

Controlled components
...

warning cuz out of sync with state? 

enchance fake browser to be in sync with input. 
so when i type in the dom, i really wan tto tye p in the fake broswr. respect the facke browser. we can wrtie some short cod tot make it into the fake broswer. 
we replace the typing behvior with something in react. 
block me from typing? what happens is, when you type, react resets the value to 42. the staet doesn't change. state value is 42. rerender to 42. it looks like you can't type. 


wehn we type, we want to change the state. 


Test.js
import React from "react";


class Test extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 42 };
  }
  handleChange(event){
    // console.log(event.target.value);
    this.setState({ x: event.target.value });
  }
  render() {
    return (
      <div>
        Testing Controlled Components
        <br />
        {this.state.x}
        <br />
        <input value={this.state.x}/>
      </div>
    );
  }
}

export default Test;

now in sync with fake broweser. taht's kind of like two way data binding. 

from reacts perspective i'm enhancing fake browswer. we call this a contorolled input component. 

if i have a button... 
import React from "react";


class Test extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 42 };
  }
  handleChange(event){
    // console.log(event.target.value);
    this.setState({ x: event.target.value });
  }
  render() {
    return (
      <div>
        Testing Controlled Components
        <br />
        {this.state.x}
        <br />
        <input value={this.state.x} 
          onChange={this.handleChange.bind(this)}
          />
        <button onClick={() => alert(this.state.x) }>Alert</button>
      </div>
    );
  }
}

export default Test;





import React from "react";

import Game from "./Game";

class Container extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <Game rows={"five"} columns={5} randomCellCount={6} />
      </div>
    );
  }
}

export default Container;


nothing happened. that's worse than an error. you don't know what's going on. 
reason is, component didn't know what to do with "five" it wants a number, not a string. 
to way to fix it is, make the component complain. 
javascript is not a typed language. that's why big players like angular and react want typs. 

Prop types

Game.propTypes = {
  rows: React.PropTypes.number,
  columns: React.PropTypes.number
}

Cell.propTypes = {
  recordGuess: React.PropTypes.func
}

it's func, not function 

is required: 
Game.propTypes = {
  rows: React.PropTypes.number.isRequired,
  columns: React.PropTypes.number.isRequired
}

default: 
Game.defaultProps = {
  rows: 5, 
  columns: 5
}



componentDidMount() {
    console.log("componentDidMount");
    setTimeout(() => {
      this.setState({ gameState: 'challenge' });
    }, 3000)
  }

  componentWillMount() {
    console.log("componentWillMount");
  }

  componentWillReceiveProps() {
    console.log("componentWillReceiveProps");
  }

  shouldComponentUpdate() {
    console.log("shouldComponentUpdate");
    return true;
  }

  componentWillUpdate() {
    console.log("componentWillUpdate");
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

didn't get comopnent will recieve props cuz props ddidn't change. state change 
at 3 second mark, state change. 


interview: 
make it so that component reieve props trigger. 

make a button on container. 

How od you change somethitn in react? you put it on the stae. 

you can't really change the props of the component? 


key changed! so react mounted a new game component. bascially, that button is a reset button! 
import React from "react";

import Game from "./Game";

class Container extends React.Component {
  constructor(props) {
    super(props);
    // this.state = { gridSize: 4 }; 
    this.state = { gameId: 1 }; 
  }
  handleClick() {
    // this.setState({ gridSize: 5 }); 
    this.setState({ gameId: this.state.gameId + 1 }); 
  }
  render() {
    var gridSize = 5; 
    return (
      <div>
        <Game key={this.state.gameId} rows={gridSize} rows={gridSize} randomCellCount={6} />
        <button onClick={this.handleClick.bind(this)}>Change</button>
      </div>
    );
  }
}

export default Container;



timer issue? 
let's try to debug this. which component is doing that? 

every time you create a timer, clear it at unmount. 

give the timer an id:


componentDidMount() {
    console.log("componentDidMount");
    this.stateTimerId = setTimeout(() => {
      this.setState({ gameState: 'challenge' });
    }, 3000)
  }

 componentWillUnmount() {
    console.log("componentWillUnmount");
    clearTimeout(this.stateTimerId);
  }

  so we have a reset button! 

  changing a key of an element makes react think it's brand new. 


  always use a unique id for element in children. dynamic. 
  not recieving props

challenge, only show the reset button if the game is won or lost. don't show it if the game is playing. 


====== lunch break ======
can do : 
this.state = { gameId: 1, resetOk: false };  

or in cgame compeont: 

ask, does this reset reset belong to game component? 
do i need a reset for every game? no right answer here. do you want it be reusable component? design quesion answer based on requirements. 

MVC fail when you have a lot of channels, entities in the system that communicate with each other freely. hard to see the connections. they work, but it's hard to maintain the connections. models depend on other models. cascading updates. when a model updates a view... cycle of depdendies that's hard to detect and fix. 
this is where a flux pattern could help. flux helps when shared state. make it constraint so that don't have mvc situation. don't have dependencies go over each other. you put a state in a flux store, a third party module. an dyou make all your react components read from that store. they can't change the state. 
if you want to change the state, you do it through a dispatcher. 
a single dispatcher in your system. 


Flux 
facebook.github.io/flux/
docs 
facebook released some tools for you to do vanilla javascript. 
facebook released the: dispatcher
singleton. 
and there's also Flux Utils 
it's directly related to redux. 